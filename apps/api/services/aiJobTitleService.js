import OpenAI from 'openai';
import pkg from '@prisma/client';

const { PrismaClient } = pkg;

const prisma = new PrismaClient();

// Initialize OpenAI client
const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
});

/**
 * AI-Powered Job Title Generation Service
 * Uses OpenAI to analyze job descriptions and generate accurate, professional titles
 */
class AIJobTitleService {
    
    /**
     * Generate job title using AI analysis
     * @param {string} description - Job description
     * @param {Object} context - Additional context (city, salary, etc.)
     * @returns {Promise<Object>} Generated title with confidence and analysis
     */
    static async generateAITitle(description, context = {}) {
        try {
            if (!process.env.OPENAI_API_KEY) {
                console.warn('‚ö†Ô∏è OpenAI API key not found. Using fallback method.');
                return this.fallbackTitleGeneration(description);
            }

            const prompt = this.buildPrompt(description, context);
            
            const completion = await openai.chat.completions.create({
                model: "gpt-3.5-turbo",
                messages: [
                    {
                        role: "system",
                        content: `You are an expert job title generator for the Israeli job market. 
                        Your task is to analyze job descriptions and generate concise, professional job titles in Russian.
                        
                        Requirements:
                        - Generate titles in Russian language
                        - Keep titles short and professional (max 5-7 words)
                        - Use specific job titles, not generic ones
                        - Consider the job location, requirements, and industry
                        - Avoid including salary, contact info, or extra details in the title
                        
                        Common job categories in Israel:
                        - –£–±–æ—Ä—â–∏–∫ (Cleaner)
                        - –ü–æ–≤–∞—Ä (Cook)
                        - –û—Ñ–∏—Ü–∏–∞–Ω—Ç (Waiter)
                        - –ì—Ä—É–∑—á–∏–∫ (Loader)
                        - –í–æ–¥–∏—Ç–µ–ª—å (Driver)
                        - –ü—Ä–æ–¥–∞–≤–µ—Ü-–∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç (Sales Consultant)
                        - –ö–∞—Å—Å–∏—Ä (Cashier)
                        - –°—Ç—Ä–æ–∏—Ç–µ–ª—å (Construction Worker)
                        - –≠–ª–µ–∫—Ç—Ä–∏–∫ (Electrician)
                        - –°–∞–Ω—Ç–µ—Ö–Ω–∏–∫ (Plumber)
                        - –ú–∞–ª—è—Ä (Painter)
                        - –ö—É—Ä—å–µ—Ä (Courier)
                        - –ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç (Programmer)
                        - –°–∏–¥–µ–ª–∫–∞ (Caregiver)
                        - –ù—è–Ω—è (Nanny)
                        - –û—Ö—Ä–∞–Ω–Ω–∏–∫ (Security Guard)
                        - –ü–∞—Ä–∏–∫–º–∞—Ö–µ—Ä (Hairdresser)
                        - –ú–∞—Å—Å–∞–∂–∏—Å—Ç (Masseur)
                        
                        Return only the job title, nothing else.`
                    },
                    {
                        role: "user",
                        content: prompt
                    }
                ],
                max_tokens: 50,
                temperature: 0.3,
            });

            const generatedTitle = completion.choices[0]?.message?.content?.trim();
            
            if (!generatedTitle) {
                throw new Error('No title generated by AI');
            }

            return {
                title: generatedTitle,
                confidence: this.calculateAIConfidence(generatedTitle, description),
                method: 'ai',
                analysis: {
                    hasSpecificKeywords: this.hasSpecificKeywords(description),
                    hasLocation: this.hasLocation(description),
                    hasSalary: this.hasSalary(description),
                    hasLanguageRequirement: this.hasLanguageRequirement(description),
                    hasExperienceRequirement: this.hasExperienceRequirement(description)
                }
            };

        } catch (error) {
            console.error('‚ùå AI title generation failed:', error.message);
            return this.fallbackTitleGeneration(description);
        }
    }

    /**
     * Build AI prompt for job title generation
     * @param {string} description - Job description
     * @param {Object} context - Additional context
     * @returns {string} Formatted prompt
     */
    static buildPrompt(description, context = {}) {
        let prompt = `Analyze this job description and generate a professional job title in Russian:\n\n`;
        prompt += `Job Description: ${description}\n\n`;
        
        if (context.city) {
            prompt += `Location: ${context.city}\n`;
        }
        if (context.salary) {
            prompt += `Salary: ${context.salary} —à–µ–∫/—á–∞—Å\n`;
        }
        if (context.requirements) {
            prompt += `Requirements: ${context.requirements}\n`;
        }
        
        prompt += `\nGenerate a concise, professional job title in Russian:`;
        
        return prompt;
    }

    /**
     * Fallback title generation when AI is not available
     * @param {string} description - Job description
     * @returns {Object} Generated title with fallback method
     */
    static fallbackTitleGeneration(description) {
        const lowerDescription = description.toLowerCase();
        
        // Simple keyword-based title generation
        let title = "–û–±—â–∞—è –≤–∞–∫–∞–Ω—Å–∏—è";
        
        if (lowerDescription.includes('–ø–æ–≤–∞—Ä') || lowerDescription.includes('–∫—É—Ö–Ω—è')) {
            title = "–ü–æ–≤–∞—Ä";
        } else if (lowerDescription.includes('—É–±–æ—Ä—â–∏–∫') || lowerDescription.includes('—É–±–æ—Ä–∫–∞')) {
            title = "–£–±–æ—Ä—â–∏–∫";
        } else if (lowerDescription.includes('–æ—Ñ–∏—Ü–∏–∞–Ω—Ç') || lowerDescription.includes('—Ä–µ—Å—Ç–æ—Ä–∞–Ω')) {
            title = "–û—Ñ–∏—Ü–∏–∞–Ω—Ç";
        } else if (lowerDescription.includes('–≥—Ä—É–∑—á–∏–∫') || lowerDescription.includes('—Å–∫–ª–∞–¥')) {
            title = "–ì—Ä—É–∑—á–∏–∫";
        } else if (lowerDescription.includes('–≤–æ–¥–∏—Ç–µ–ª—å') || lowerDescription.includes('–¥–æ—Å—Ç–∞–≤–∫–∞')) {
            title = "–í–æ–¥–∏—Ç–µ–ª—å";
        } else if (lowerDescription.includes('–ø—Ä–æ–¥–∞–≤–µ—Ü') || lowerDescription.includes('–º–∞–≥–∞–∑–∏–Ω')) {
            title = "–ü—Ä–æ–¥–∞–≤–µ—Ü-–∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç";
        } else if (lowerDescription.includes('–∫–∞—Å—Å–∏—Ä') || lowerDescription.includes('–∫–∞—Å—Å–∞')) {
            title = "–ö–∞—Å—Å–∏—Ä";
        } else if (lowerDescription.includes('—Å—Ç—Ä–æ–∏—Ç–µ–ª—å') || lowerDescription.includes('—Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ')) {
            title = "–°—Ç—Ä–æ–∏—Ç–µ–ª—å";
        } else if (lowerDescription.includes('—ç–ª–µ–∫—Ç—Ä–∏–∫')) {
            title = "–≠–ª–µ–∫—Ç—Ä–∏–∫";
        } else if (lowerDescription.includes('—Å–∞–Ω—Ç–µ—Ö–Ω–∏–∫')) {
            title = "–°–∞–Ω—Ç–µ—Ö–Ω–∏–∫";
        } else if (lowerDescription.includes('–º–∞–ª—è—Ä')) {
            title = "–ú–∞–ª—è—Ä";
        } else if (lowerDescription.includes('–∫—É—Ä—å–µ—Ä')) {
            title = "–ö—É—Ä—å–µ—Ä";
        } else if (lowerDescription.includes('–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç')) {
            title = "–ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç";
        } else if (lowerDescription.includes('—Å–∏–¥–µ–ª–∫–∞')) {
            title = "–°–∏–¥–µ–ª–∫–∞";
        } else if (lowerDescription.includes('–Ω—è–Ω—è')) {
            title = "–ù—è–Ω—è";
        } else if (lowerDescription.includes('–æ—Ö—Ä–∞–Ω–Ω–∏–∫')) {
            title = "–û—Ö—Ä–∞–Ω–Ω–∏–∫";
        } else if (lowerDescription.includes('–ø–∞—Ä–∏–∫–º–∞—Ö–µ—Ä')) {
            title = "–ü–∞—Ä–∏–∫–º–∞—Ö–µ—Ä";
        } else if (lowerDescription.includes('–º–∞—Å—Å–∞–∂–∏—Å—Ç')) {
            title = "–ú–∞—Å—Å–∞–∂–∏—Å—Ç";
        }
        
        return {
            title: title,
            confidence: 0.6, // Lower confidence for rule-based method
            method: 'rule-based',
            analysis: {
                hasSpecificKeywords: this.hasSpecificKeywords(description),
                hasLocation: this.hasLocation(description),
                hasSalary: this.hasSalary(description),
                hasLanguageRequirement: this.hasLanguageRequirement(description),
                hasExperienceRequirement: this.hasExperienceRequirement(description)
            }
        };
    }

    /**
     * Calculate confidence score for AI-generated title
     * @param {string} title - Generated title
     * @param {string} description - Original description
     * @returns {number} Confidence score (0-1)
     */
    static calculateAIConfidence(title, description) {
        if (!title || !description) return 0;
        
        const lowerTitle = title.toLowerCase();
        const lowerDescription = description.toLowerCase();
        
        // Check if title keywords appear in description
        const titleWords = lowerTitle.split(' ').filter(word => word.length > 2);
        const matchingWords = titleWords.filter(word => lowerDescription.includes(word));
        
        // Calculate basic confidence
        let confidence = matchingWords.length / Math.max(titleWords.length, 1);
        
        // Boost confidence for AI-generated titles
        confidence += 0.2;
        
        // Reduce confidence for generic titles
        if (lowerTitle.includes('–æ–±—â–∞—è') || lowerTitle.includes('—Ä–∞–±–æ—Ç–Ω–∏–∫')) {
            confidence -= 0.3;
        }
        
        return Math.min(Math.max(confidence, 0), 1);
    }

    /**
     * Batch generate titles for multiple jobs
     * @param {Array} jobs - Array of job objects
     * @returns {Promise<Array>} Array of jobs with AI-generated titles
     */
    static async batchGenerateAITitles(jobs) {
        console.log(`ü§ñ Starting AI-powered title generation for ${jobs.length} jobs...`);
        
        const results = [];
        let successCount = 0;
        let errorCount = 0;
        
        for (const job of jobs) {
            try {
                const context = {
                    city: job.city?.name,
                    salary: job.salary,
                    requirements: this.extractRequirements(job.description)
                };
                
                const titleData = await this.generateAITitle(job.description, context);
                
                results.push({
                    ...job,
                    title: titleData.title,
                    titleConfidence: titleData.confidence,
                    titleMethod: titleData.method,
                    titleAnalysis: titleData.analysis
                });
                
                successCount++;
                
                // Log progress every 10 jobs
                if (successCount % 10 === 0) {
                    console.log(`‚úÖ Processed ${successCount}/${jobs.length} jobs`);
                }
                
                // Add small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
                
            } catch (error) {
                console.error(`‚ùå Failed to generate title for job ${job.id}:`, error.message);
                errorCount++;
                
                // Use fallback for failed jobs
                const fallbackData = this.fallbackTitleGeneration(job.description);
                results.push({
                    ...job,
                    title: fallbackData.title,
                    titleConfidence: fallbackData.confidence,
                    titleMethod: 'fallback',
                    titleAnalysis: fallbackData.analysis
                });
            }
        }
        
        console.log(`\nüìä AI Title Generation Summary:`);
        console.log(`   Total jobs: ${jobs.length}`);
        console.log(`   Successfully processed: ${successCount}`);
        console.log(`   Errors (using fallback): ${errorCount}`);
        
        return results;
    }

    /**
     * Extract requirements from job description
     * @param {string} description - Job description
     * @returns {string} Extracted requirements
     */
    static extractRequirements(description) {
        const requirementPatterns = [
            /—Ç—Ä–µ–±—É–µ—Ç—Å—è\s+(.+?)(?=\n|$)/i,
            /—Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è?\s*:\s*(.+?)(?=\n|$)/i,
            /–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ\s+(.+?)(?=\n|$)/i
        ];
        
        for (const pattern of requirementPatterns) {
            const match = description.match(pattern);
            if (match) {
                return match[1].trim();
            }
        }
        
        return '';
    }

    /**
     * Check if description has specific job keywords
     * @param {string} description - Job description
     * @returns {boolean}
     */
    static hasSpecificKeywords(description) {
        const specificKeywords = [
            '–ø–æ–≤–∞—Ä', '–æ—Ñ–∏—Ü–∏–∞–Ω—Ç', '–≥—Ä—É–∑—á–∏–∫', '–≤–æ–¥–∏—Ç–µ–ª—å', '–ø—Ä–æ–¥–∞–≤–µ—Ü', 
            '–∫–∞—Å—Å–∏—Ä', '—É–±–æ—Ä—â–∏–∫', '—Å—Ç—Ä–æ–∏—Ç–µ–ª—å', '—ç–ª–µ–∫—Ç—Ä–∏–∫', '—Å–∞–Ω—Ç–µ—Ö–Ω–∏–∫',
            '–º–∞–ª—è—Ä', '–∫—É—Ä—å–µ—Ä', '–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç', '—Å–∏–¥–µ–ª–∫–∞', '–Ω—è–Ω—è'
        ];
        
        return specificKeywords.some(keyword => 
            description.toLowerCase().includes(keyword)
        );
    }

    /**
     * Check if description mentions a location
     * @param {string} description - Job description
     * @returns {boolean}
     */
    static hasLocation(description) {
        const locationPatterns = [
            /–≤\s+([–∞-—è—ë]+(?:\s+[–∞-—è—ë]+)*)/i,
            /–Ω–∞\s+([–∞-—è—ë]+(?:\s+[–∞-—è—ë]+)*)/i
        ];
        
        return locationPatterns.some(pattern => pattern.test(description));
    }

    /**
     * Check if description mentions salary
     * @param {string} description - Job description
     * @returns {boolean}
     */
    static hasSalary(description) {
        const salaryPattern = /(\d+)\s*(?:—à–µ–∫|‚Ç™|ILS)/i;
        return salaryPattern.test(description);
    }

    /**
     * Check if description has language requirements
     * @param {string} description - Job description
     * @returns {boolean}
     */
    static hasLanguageRequirement(description) {
        const languageKeywords = ['–∏–≤—Ä–∏—Ç', '–∏–≤—Ä–∏—Ç–æ–º', '–∞–Ω–≥–ª–∏–π—Å–∫–∏–π', '–∞–Ω–≥–ª–∏–π—Å–∫–∏–º', '—Ä—É—Å—Å–∫–∏–π', '—Ä—É—Å—Å–∫–∏–º'];
        return languageKeywords.some(keyword => 
            description.toLowerCase().includes(keyword)
        );
    }

    /**
     * Check if description mentions experience requirements
     * @param {string} description - Job description
     * @returns {boolean}
     */
    static hasExperienceRequirement(description) {
        const experienceKeywords = ['–æ–ø—ã—Ç', '–æ–ø—ã—Ç–Ω—ã–π', '–æ–ø—ã—Ç —Ä–∞–±–æ—Ç—ã'];
        return experienceKeywords.some(keyword => 
            description.toLowerCase().includes(keyword)
        );
    }

    /**
     * Update existing jobs in database with AI-generated titles
     * @returns {Promise<Object>} Update statistics
     */
    static async updateDatabaseWithAITitles() {
        console.log("ü§ñ Updating database with AI-generated titles...\n");
        
        try {
            const jobs = await prisma.job.findMany({
                include: {
                    city: true,
                    category: true
                }
            });
            
            console.log(`üìä Found ${jobs.length} jobs to update\n`);
            
            let updatedCount = 0;
            let skippedCount = 0;
            let errorCount = 0;
            
            for (const job of jobs) {
                try {
                    const context = {
                        city: job.city?.name,
                        salary: job.salary,
                        requirements: this.extractRequirements(job.description)
                    };
                    
                    const titleData = await this.generateAITitle(job.description, context);
                    
                    // Only update if the new title is better
                    if (titleData.confidence > 0.7 && titleData.title !== job.title) {
                        await prisma.job.update({
                            where: { id: job.id },
                            data: { title: titleData.title }
                        });
                        
                        console.log(`‚úÖ Updated: "${job.title}" ‚Üí "${titleData.title}" (${titleData.method})`);
                        updatedCount++;
                    } else {
                        console.log(`‚è≠Ô∏è  Skipping "${job.title}" - confidence: ${titleData.confidence.toFixed(2)}`);
                        skippedCount++;
                    }
                    
                    // Add delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                } catch (error) {
                    console.error(`‚ùå Failed to update job ${job.id}:`, error.message);
                    errorCount++;
                }
            }
            
            console.log(`\nüìà AI Update Summary:`);
            console.log(`   Total jobs processed: ${jobs.length}`);
            console.log(`   Jobs updated: ${updatedCount}`);
            console.log(`   Jobs skipped: ${skippedCount}`);
            console.log(`   Errors: ${errorCount}`);
            
            return {
                total: jobs.length,
                updated: updatedCount,
                skipped: skippedCount,
                errors: errorCount
            };
            
        } catch (error) {
            console.error('‚ùå Error updating database with AI titles:', error);
            throw error;
        }
    }
}

export default AIJobTitleService; 